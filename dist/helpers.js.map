{"version":3,"sources":["../src/helpers.js"],"names":["optimizeImage","buildTestFunction","hashContent","invokeIfFunction","getFromCacheIfPossible","exists","writeFile","templatedFilePath","readFile","fs","writeFileAsync","mkdirpAsync","mkdirp","imageData","fileName","imageminOptions","onlyUseIfSmaller","sizeInfo","imageBuffer","Buffer","isBuffer","from","originalSize","length","optimizedImageBuffer","imagemin","buffer","optimizedSize","savedBytes","savedPercentage","console","log","toFixed","rawTestValue","minFileSize","maxFileSize","testFunctions","compileRegex","filename","assetSource","func","content","crypto","createHash","update","digest","cacheFolder","elseFunc","cacheFilePath","path","resolve","fileBuffer","directory","reject","access","constants","R_OK","W_OK","err","dirname","tests","Array","isArray","map","test","RegExp","regex","Error","filePath","originalFilePath","replace","split","basename","extname"],"mappings":"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","file":"helpers.js","sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport crypto from 'crypto'\nimport { makeRe } from 'minimatch'\nimport imagemin from 'imagemin'\nimport mkdirp from 'mkdirp'\nimport promisify from 'util.promisify'\nimport prettyBytes from 'pretty-bytes'\n\nexport const readFile = promisify(fs.readFile)\nconst writeFileAsync = promisify(fs.writeFile)\nconst mkdirpAsync = promisify(mkdirp)\n\n/**\n * Optimizes a single image\n * returns the orignal if the \"optimized\" version is larger (only if the onlyUseIfSmaller option is true)\n * @param  {Object}  imageData\n * @param  {Object}  imageminOptions\n * @return {Promise(asset)}\n */\nexport async function optimizeImage (imageData, fileName, { imageminOptions, onlyUseIfSmaller, sizeInfo }) {\n  // Ensure that the contents i have are in the form of a buffer\n  const imageBuffer = (Buffer.isBuffer(imageData) ? imageData : Buffer.from(imageData, 'utf8'))\n  // And get the original size for comparison later to make sure it actually got smaller\n  const originalSize = imageBuffer.length\n\n  // Await for imagemin to do the compression\n  const optimizedImageBuffer = await imagemin.buffer(imageBuffer, imageminOptions)\n  if (sizeInfo) {\n    const optimizedSize = optimizedImageBuffer.length\n    const savedBytes = originalSize - optimizedSize\n    var savedPercentage = 0\n    if (originalSize > 0) {\n      savedPercentage = (savedBytes / originalSize) * 100\n      console.log(`{imagemin} ${fileName} - original: ${prettyBytes(originalSize)} optimized: ${prettyBytes(optimizedSize)} saved: ${Number.parseFloat(savedPercentage).toFixed(1)}%`)\n    } else {\n      console.log(`{imagemin} ${fileName} image already optimized`)\n    }\n  }\n\n  // If onlyUseIfSmaller is true, and the optimization actually produced a LARGER file, then return the original version\n  if (onlyUseIfSmaller && optimizedImageBuffer.length > originalSize) {\n    return imageBuffer\n  } else {\n    return optimizedImageBuffer\n  }\n}\n\n/**\n * Tests a filename to see if it matches any of the given test functions\n * This function is curried, pass in the first 3 params first, then the next 2\n * for each test needed\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\n * @param  {Number} minFileSize\n * @param  {Number} maxFileSize\n * @return {Boolean}\n */\nexport function buildTestFunction (rawTestValue, minFileSize, maxFileSize) {\n  const testFunctions = compileRegex(rawTestValue)\n  /**\n   * @param  {String}      filename\n   * @param  {assetSource} assetSource\n   * @return {Boolean}\n   */\n  return (filename, assetSource) => {\n    for (let func of testFunctions) {\n      if (func(filename) === true) {\n        return assetSource.length > minFileSize && assetSource.length <= maxFileSize\n      }\n    }\n    return false\n  }\n}\n\n/**\n * hashes file contents to make sure I can uniquely store a file even with absolute paths\n * @param  {string} content  File contents\n * @return {string}          A hash of the full file contents\n */\nexport function hashContent (content) {\n  return crypto.createHash('sha1').update(content).digest('hex')\n}\n\n/**\n * Invokes the passed in argument if it's a function\n * @param  {Function|Any}  func\n * @return {Any}\n */\nexport function invokeIfFunction (func) {\n  if (typeof func === 'function') {\n    return func()\n  } else {\n    return func\n  }\n}\n\n/**\n * Gets the buffer of the file from cache. If it doesn't exist or the cache is\n * not enabled, it will invoke elseFunc and use it's result as the result of the\n * function, saving the result in the cache\n * @param  {String} cacheFolder\n * @param  {String} content\n * @param  {Function} elseFunc\n * @return {Buffer}\n */\nexport async function getFromCacheIfPossible (cacheFolder, content, elseFunc) {\n  let cacheFilePath\n  if (cacheFolder !== null) {\n    cacheFilePath = path.resolve(cacheFolder, hashContent(content))\n    if (await exists(cacheFilePath)) {\n      return readFile(cacheFilePath)\n    }\n  }\n\n  const fileBuffer = await elseFunc()\n  if (cacheFolder !== null) {\n    await writeFile(cacheFilePath, fileBuffer)\n  }\n  return fileBuffer\n}\n\n/**\n * checks if a file/directory is accessable\n * @param {any} directory\n * @returns\n */\nexport async function exists (directory) {\n  return new Promise((resolve, reject) => {\n    fs.access(directory, fs.constants.R_OK | fs.constants.W_OK, (err) => {\n      if (err) {\n        resolve(false)\n      } else {\n        resolve(true)\n      }\n    })\n  })\n}\n\n/**\n * async wrapper for writeFile that will create the directory if it does not already exist\n * @param {String} filename\n * @param {Buffer} buffer\n * @returns\n */\nexport async function writeFile (filename, buffer) {\n  const directory = path.dirname(filename)\n  // if the directory doesn't exist, create it\n  if (!(await exists(directory))) {\n    await mkdirpAsync(directory)\n  }\n\n  return writeFileAsync(filename, buffer)\n}\n\n/**\n * Compiles a regex, glob, function, or an array of any of them to an array of functions\n * @param  {RegExp|RegExp[]|Function|Function[]|String|String[]} rawTestValue\n * @return {Function[]}\n */\nfunction compileRegex (rawTestValue) {\n  const tests = Array.isArray(rawTestValue) ? rawTestValue : [rawTestValue]\n\n  return tests.map((test) => {\n    if (typeof test === 'function') {\n      // if it's a function, just return this\n      return test\n    } else if (test instanceof RegExp) {\n      // If it's a regex return it wrapped in a function\n      return (filename) => test.test(filename)\n    } else if (typeof test === 'string') {\n      // If it's a string, let minimatch convert it to a regex then wrap that in a function\n      const regex = makeRe(test)\n      return (filename) => regex.test(filename)\n    } else {\n      throw new Error('test parameter must be a regex, glob string, function, or an array of any of them')\n    }\n  })\n}\n\n/**\n * Replaces file name templates for a given path. Inspired by webpack's output.filename config.\n * @param {String|Function} fileName\n * @param {String} filePath\n * @returns {String}\n */\nexport function templatedFilePath (fileName, filePath) {\n  if (typeof fileName === 'function') {\n    return fileName(filePath)\n  }\n\n  if (typeof fileName === 'string') {\n    const originalFilePath = filePath\n\n    return fileName\n      .replace('[path]', originalFilePath.split(path.basename(originalFilePath))[0])\n      .replace('[name]', path.basename(originalFilePath, path.extname(originalFilePath)))\n      .replace('[ext]', path.extname(originalFilePath).split('.')[1])\n  }\n\n  throw new Error('fileName parameter must be a string or a function')\n}\n"]}