{"version":3,"sources":["../src/index.js"],"names":["ImageminPlugin","constructor","options","disable","test","minFileSize","maxFileSize","Infinity","maxConcurrency","length","plugins","optipng","optimizationLevel","gifsicle","jpegtran","progressive","svgo","pngquant","externalImages","cacheFolder","sizeInfo","onlyUseIfSmaller","imageminOptions","testFunction","context","sources","destination","fileName","plugin","pluginOptions","imageminOptipng","imageminGifsicle","imageminJpegtran","imageminSvgo","imageminPngquant","push","apply","compiler","compilerOptions","onEmit","compilation","callback","throttle","all","optimizeWebpackImages","optimizeExternalImages","err","hooks","emit","tapAsync","name","assets","asset","filename","assetSource","source","optimizedImageBuffer","path","basename","RawSource","fullContext","resolve","invokedDestination","relativeFilePath","relative","fileData","writeFilePath","join"],"mappings":";;;;;;;;;;;;;;AAAA;;;;AACA;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AAEA;;;;AAUe,MAAMA,cAAN,CAAqB;AAClCC,cAAaC,UAAU,EAAvB,EAA2B;AACzB,UAAM;AACJC,gBAAU,KADN;AAEJC,aAAO,IAFH;AAGJC,oBAAc,CAHV;AAIJC,oBAAcC,QAJV;AAKJC,uBAAiB,gBAAOC,MALpB;AAMJC,gBAAU,EANN;AAOJC,gBAAU;AACRC,2BAAmB;AADX,OAPN;AAUJC,iBAAW;AACTD,2BAAmB;AADV,OAVP;AAaJE,iBAAW;AACTC,qBAAa;AADJ,OAbP;AAgBJC,aAAO,EAhBH;AAiBJC,iBAAW,IAjBP;AAkBJC,uBAAiB,EAlBb;AAmBJC,oBAAc,IAnBV;AAoBJC,iBAAW,KApBP;AAqBJC,yBAAmB;AArBf,QAsBFnB,OAtBJ;;AAwBA,SAAKA,OAAL,GAAe;AACbC,aADa;AAEbK,oBAFa;AAGbc,uBAAiB;AACfZ,iBAAS;AADM,OAHJ;AAMba,oBAAc,gCAAkBnB,IAAlB,EAAwBC,WAAxB,EAAqCC,WAArC,CAND;AAObY;AACEM,iBAAS,GADX;AAEEC,iBAAS,EAFX;AAGEC,qBAAa,GAHf;AAIEC,kBAAU;AAJZ,SAKKT,cALL,CAPa;AAcbC,iBAda;AAebC,cAfa;AAgBbC;;AAGF;AACA;AApBe,KAAf,CAqBA,KAAK,IAAI,CAACO,MAAD,EAASC,aAAT,CAAT,IAAoC,CAClC,CAACC,yBAAD,EAAkBnB,OAAlB,CADkC,EAElC,CAACoB,0BAAD,EAAmBlB,QAAnB,CAFkC,EAGlC,CAACmB,0BAAD,EAAmBlB,QAAnB,CAHkC,EAIlC,CAACmB,sBAAD,EAAejB,IAAf,CAJkC,EAKlC,CAACkB,0BAAD,EAAmBjB,QAAnB,CALkC,CAApC,EAMG;AACD,UAAIY,kBAAkB,IAAtB,EAA4B;AAC1B,aAAK3B,OAAL,CAAaoB,eAAb,CAA6BZ,OAA7B,CAAqCyB,IAArC,CAA0CP,OAAOC,aAAP,CAA1C;AACD;AACF;;AAED;AACA,SAAK3B,OAAL,CAAaoB,eAAb,CAA6BZ,OAA7B,CAAqCyB,IAArC,CAA0C,GAAGzB,OAA7C;AACD;;AAED0B,QAAOC,QAAP,EAAiB;AACf;AACA,SAAKnC,OAAL,CAAaoC,eAAb,GAA+BD,SAASnC,OAAxC;;AAEA;AACA,QAAI,KAAKA,OAAL,CAAaC,OAAb,KAAyB,IAA7B,EAAmC,OAAO,IAAP;;AAEnC;AACA,UAAMoC,SAAS,OAAOC,WAAP,EAAoBC,QAApB,KAAiC;AAC9C;AACA,YAAMC,WAAW,6BAAe,KAAKxC,OAAL,CAAaM,cAA5B,CAAjB;;AAEA,UAAI;AACF;AACA;AACA,cAAM,kBAAQmC,GAAR,CAAY,CAChB,GAAG,KAAKC,qBAAL,CAA2BF,QAA3B,EAAqCF,WAArC,CADa,EAEhB,GAAG,KAAKK,sBAAL,CAA4BH,QAA5B,CAFa,CAAZ,CAAN;;AAKA;AACAD;AACD,OAVD,CAUE,OAAOK,GAAP,EAAY;AACZ;AACAL,iBAASK,GAAT;AACD;AACF,KAlBD;;AAoBA;AACA,QAAIT,SAASU,KAAb,EAAoB;AAClB;AACAV,eAASU,KAAT,CAAeC,IAAf,CAAoBC,QAApB,CAA6B,KAAKhD,WAAL,CAAiBiD,IAA9C,EAAoDX,MAApD;AACD,KAHD,MAGO;AACL;AACAF,eAAST,MAAT,CAAgB,MAAhB,EAAwBW,MAAxB;AACD;AACF;;AAED;;;;;;AAMAK,wBAAuBF,QAAvB,EAAiCF,WAAjC,EAA8C;AAC5C,UAAM;AACJjB,kBADI;AAEJJ;AAFI,QAGF,KAAKjB,OAHT;;AAKA;AACA;AACA,WAAO,sBAAIsC,YAAYW,MAAhB,EAAwB,CAACC,KAAD,EAAQC,QAAR,KAAqBX,SAAS,YAAY;AACvE,YAAMY,cAAcF,MAAMG,MAAN,EAApB;AACA;AACA,UAAIhC,aAAa8B,QAAb,EAAuBC,WAAvB,CAAJ,EAAyC;AACvC;AACA;AACA,YAAIE,uBAAuB,MAAM,qCAAuBrC,WAAvB,EAAoCmC,WAApC,EAAiD,MAAM;AACtF,iBAAO,4BAAcA,WAAd,EAA2BG,eAAKC,QAAL,CAAcL,QAAd,CAA3B,EAAoD,KAAKnD,OAAzD,CAAP;AACD,SAFgC,CAAjC;;AAIA;AACAsC,oBAAYW,MAAZ,CAAmBE,QAAnB,IAA+B,IAAIM,mBAAJ,CAAcH,oBAAd,CAA/B;AACD;AACF,KAbmD,CAA7C,CAAP;AAcD;;AAED;;;;;AAKAX,yBAAwBH,QAAxB,EAAkC;AAChC,UAAM;AACJJ,qBADI;AAEJpB,sBAAgB;AACdM,eADc;AAEdC,eAFc;AAGdC,mBAHc;AAIdC;AAJc,OAFZ;AAQJJ,kBARI;AASJJ;AATI,QAUF,KAAKjB,OAVT;;AAYA,UAAM0D,cAAcH,eAAKI,OAAL,CAAavB,gBAAgBd,OAA7B,EAAsCA,OAAtC,CAApB;;AAEA,UAAMsC,qBAAqBL,eAAKI,OAAL,CAAa,+BAAiBnC,WAAjB,CAAb,CAA3B;;AAEA,WAAO,sBAAI,+BAAiBD,OAAjB,CAAJ,EAAgC4B,QAAD,IAAcX,SAAS,YAAY;AACvE,UAAIqB,mBAAmBN,eAAKO,QAAL,CAAcJ,WAAd,EAA2BP,QAA3B,CAAvB;AACA,YAAMY,WAAW,MAAM,uBAASR,eAAKI,OAAL,CAAaD,WAAb,EAA0BG,gBAA1B,CAAT,CAAvB;AACA,UAAIxC,aAAa8B,QAAb,EAAuBY,QAAvB,CAAJ,EAAsC;AACpC;AACA;AACA,YAAIT,uBAAuB,MAAM,qCAAuBrC,WAAvB,EAAoC8C,QAApC,EAA8C,YAAY;AACzF,iBAAO,4BAAcA,QAAd,EAAwBR,eAAKC,QAAL,CAAcL,QAAd,CAAxB,EAAiD,KAAKnD,OAAtD,CAAP;AACD,SAFgC,CAAjC;;AAIA,YAAIyB,QAAJ,EAAc;AACZoC,6BAAmB,gCAAkBpC,QAAlB,EAA4BoC,gBAA5B,CAAnB;AACD;;AAED,cAAMG,gBAAgBT,eAAKU,IAAL,CAAUL,kBAAV,EAA8BC,gBAA9B,CAAtB;;AAEA;AACA,eAAO,wBAAUG,aAAV,EAAyBV,oBAAzB,CAAP;AACD;AACF,KAnBmD,CAA7C,CAAP;AAoBD;AA7KiC;kBAAfxD,c","file":"index.js","sourcesContent":["import path from 'path'\nimport { cpus } from 'os'\nimport map from 'lodash.map'\nimport imageminSvgo from 'imagemin-svgo'\nimport createThrottle from 'async-throttle'\nimport imageminOptipng from 'imagemin-optipng'\nimport imageminPngquant from 'imagemin-pngquant'\nimport imageminGifsicle from 'imagemin-gifsicle'\nimport imageminJpegtran from 'imagemin-jpegtran'\nimport RawSource from 'webpack-sources/lib/RawSource'\n\nimport {\n  buildTestFunction,\n  invokeIfFunction,\n  getFromCacheIfPossible,\n  readFile,\n  writeFile,\n  optimizeImage,\n  templatedFilePath\n} from './helpers.js'\n\nexport default class ImageminPlugin {\n  constructor (options = {}) {\n    const {\n      disable = false,\n      test = /.*/,\n      minFileSize = 0,\n      maxFileSize = Infinity,\n      maxConcurrency = cpus().length,\n      plugins = [],\n      optipng = {\n        optimizationLevel: 3\n      },\n      gifsicle = {\n        optimizationLevel: 1\n      },\n      jpegtran = {\n        progressive: false\n      },\n      svgo = {},\n      pngquant = null,\n      externalImages = {},\n      cacheFolder = null,\n      sizeInfo = false,\n      onlyUseIfSmaller = false\n    } = options\n\n    this.options = {\n      disable,\n      maxConcurrency,\n      imageminOptions: {\n        plugins: []\n      },\n      testFunction: buildTestFunction(test, minFileSize, maxFileSize),\n      externalImages: {\n        context: '.',\n        sources: [],\n        destination: '.',\n        fileName: null,\n        ...externalImages\n      },\n      cacheFolder,\n      sizeInfo,\n      onlyUseIfSmaller\n    }\n\n    // As long as the options aren't `null` then include the plugin. Let the destructuring above\n    // control whether the plugin is included by default or not.\n    for (let [plugin, pluginOptions] of [\n      [imageminOptipng, optipng],\n      [imageminGifsicle, gifsicle],\n      [imageminJpegtran, jpegtran],\n      [imageminSvgo, svgo],\n      [imageminPngquant, pngquant]\n    ]) {\n      if (pluginOptions !== null) {\n        this.options.imageminOptions.plugins.push(plugin(pluginOptions))\n      }\n    }\n\n    // And finally, add any plugins that they pass in the options to the internal plugins array\n    this.options.imageminOptions.plugins.push(...plugins)\n  }\n\n  apply (compiler) {\n    // Add the compiler options to my options\n    this.options.compilerOptions = compiler.options\n\n    // If disabled, short-circuit here and just return\n    if (this.options.disable === true) return null\n\n    // Access the assets once they have been assembled\n    const onEmit = async (compilation, callback) => {\n      // Create a throttle object which will limit the number of concurrent processes running\n      const throttle = createThrottle(this.options.maxConcurrency)\n\n      try {\n        // Optimise all images at the same time (throttled to maxConcurrency)\n        // and await until all of them to complete\n        await Promise.all([\n          ...this.optimizeWebpackImages(throttle, compilation),\n          ...this.optimizeExternalImages(throttle)\n        ])\n\n        // At this point everything is done, so call the callback without anything in it\n        callback()\n      } catch (err) {\n        // if at any point we hit a snag, pass the error on to webpack\n        callback(err)\n      }\n    }\n\n    // Check if the webpack 4 plugin API is available\n    if (compiler.hooks) {\n      // Register emit event listener for webpack 4\n      compiler.hooks.emit.tapAsync(this.constructor.name, onEmit)\n    } else {\n      // Register emit event listener for older webpack versions\n      compiler.plugin('emit', onEmit)\n    }\n  }\n\n  /**\n   * Optimize images from webpack and put them back in the asset array when done\n   * @param  {Function} throttle       The setup throttle library\n   * @param  {Object} compilation      The compilation from webpack-sources\n   * @return {Promise[]}               An array of promises that resolve when each image is done being optimized\n   */\n  optimizeWebpackImages (throttle, compilation) {\n    const {\n      testFunction,\n      cacheFolder\n    } = this.options\n\n    // Return an array of promises that resolve when each file is done being optimized\n    // pass everything through the throttle function to limit maximum concurrency\n    return map(compilation.assets, (asset, filename) => throttle(async () => {\n      const assetSource = asset.source()\n      // Skip the image if it's not a match for the regex or it's too big/small\n      if (testFunction(filename, assetSource)) {\n        // Use the helper function to get the file from cache if possible, or\n        // run the optimize function and store it in the cache when done\n        let optimizedImageBuffer = await getFromCacheIfPossible(cacheFolder, assetSource, () => {\n          return optimizeImage(assetSource, path.basename(filename), this.options)\n        })\n\n        // Then write the optimized version back to the asset object as a \"raw source\"\n        compilation.assets[filename] = new RawSource(optimizedImageBuffer)\n      }\n    }))\n  }\n\n  /**\n   * Optimizes external images\n   * @param  {Function} throttle The setup throttle library\n   * @return {Promise[]}         An array of promises that resolve when each image is done being optimized\n   */\n  optimizeExternalImages (throttle) {\n    const {\n      compilerOptions,\n      externalImages: {\n        context,\n        sources,\n        destination,\n        fileName\n      },\n      testFunction,\n      cacheFolder\n    } = this.options\n\n    const fullContext = path.resolve(compilerOptions.context, context)\n\n    const invokedDestination = path.resolve(invokeIfFunction(destination))\n\n    return map(invokeIfFunction(sources), (filename) => throttle(async () => {\n      let relativeFilePath = path.relative(fullContext, filename)\n      const fileData = await readFile(path.resolve(fullContext, relativeFilePath))\n      if (testFunction(filename, fileData)) {\n        // Use the helper function to get the file from cache if possible, or\n        // run the optimize function and store it in the cache when done\n        let optimizedImageBuffer = await getFromCacheIfPossible(cacheFolder, fileData, async () => {\n          return optimizeImage(fileData, path.basename(filename), this.options)\n        })\n\n        if (fileName) {\n          relativeFilePath = templatedFilePath(fileName, relativeFilePath)\n        }\n\n        const writeFilePath = path.join(invokedDestination, relativeFilePath)\n\n        // Write the file to the destination when done\n        return writeFile(writeFilePath, optimizedImageBuffer)\n      }\n    }))\n  }\n}\n"]}